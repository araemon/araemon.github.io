---
title:"SwiftでRingBuffer(待ち行列)のQueueを作って100万回処理してみる"
date:"2018-12-21"
category:"blog"
---
image:/images/queue-image.jpg
開発中のOSS<a href="/oss/chimaki-1.html">「ChiMAKi」</a>に、QueueのKitを追加するまでの記事です。

Swiftの場合、Queueを作るとしたら次のようなプログラミングが考えられます。
`Queue.swift`
```
var max:Int!
var data:[Any] = []

init(_ max:Int) {
    self.max = max
}

func enqueue(_ obj:Any) -> Bool {
    if data.count > self.max - 1 {
        return false
    }
    data.append(obj)
    return true
}

func dequeue() -> Any? {
    if data.count > 0 {
        let obj = data[0]
        data.remove(at: 0)
        return obj
    }
    return nil
}
```

単純なプログラムでサクッと作れました。
しかしこのようなアルゴリズムは、特にC言語の場合では問題があるようです。先頭配列を削除するというのは、配列を前方にシフトする処理を行うというこになるので、速度が遅くなってしまうのです。何か良い方法があるのではと思いQueueのプログラムを調べていくと、リングバッファーというアルゴリズムが見つかりました。

image300:/images/queue-ring-buffer.jpg

サイズの決まった配列を作り、輪のように見立てて考えます。0番から順番にデータを入れていきます。一周回ったら、また0番に戻ってデータを入れていきます。こうすることで、配列をシフトする処理の必要が無くなります。カウントの管理はheadとnumの値で管理します。enqueueしたらnumカウントを1プラスするようにし、dequeueしたら、headカウンタを1プラスします。enqueueすべきインデックスはhead+num番となります。dequeueすべきインデックスはhead番となります。

リングバッファーの説明およびプログラミングは、こちらのサイトが大変参考になりました。
http://www.cc.kyoto-su.ac.jp/~yamada/ap/queue.html


さて、このリングバッファーのQueueを、Swiftでもやってみたいと思いプログラミングしてみました。
`RingQueue.swift`
```
var head:Int = 0
var num:Int = 0
var max:Int = 0
var data:[Any]!
var debug = false

init(_ max:Int) {
    self.max = max
    self.data = Array<Any>(repeating: -1, count: max)
}

@discardableResult
func enqueue(_ obj:Any) -> Bool { // キューが一杯だったらfalseを返す
    if num < max {
        self.data[(head + num) % max] = obj
        num = num + 1
        return true
    }
    return false
}

@discardableResult
func dequeue() -> Any? {
    if num > 0 {
        let obj = data[head]
        data[head] = -1
        num = num - 1
        head = (head + 1) % max;
        return obj
    }
    return nil
}
```

動作確認を行うために、XCTestで次のプログラムを組んで確認してみます。
```
let max = 5
let loop = 3
var num = 0
func sequenceNo() -> Int {
    num = num + 1
    return num
}

func testRingQueue() {
    let q = RingQueue(max)
    
    for _ in 0..<loop {
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.dequeue()
        q.dequeue()
        q.dequeue()
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.dequeue()
        q.enqueue(sequenceNo())
        q.dequeue()
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.dequeue()
        q.dequeue()
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
    }

}
```

動作確認の結果です。一つ一つ丁寧に追っていくと、ちゃんとキューイングできていることがわかります。
image300:/images/queue-test-trace.jpg


さらに、最初に作った`Queue.swift`と、先ほどの`RingQueue.swift`で速度比較実験を行ってみました。
次のようなXCTestCaseを書いて、速度を比較してみます。
```
let max = 1000
let loop = 100*100*100

var num = 0
func sequenceNo() -> String {
    num = num + 1
    return "hogehogehogehoge\(num)"
}

func testQueue() {
    print("[Queue.swift]\n\n\n")
    let q = Queue(max)


    for _ in 0..<loop {
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.dequeue()
        q.dequeue()
        q.dequeue()
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.dequeue()
        q.enqueue(sequenceNo())
        q.dequeue()
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.dequeue()
        q.dequeue()
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
    }

}


func testRingQueue() {
    print("[RingQueue.swift]\n\n\n")
    let q = RingQueue(max)
    
    for _ in 0..<loop {
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.dequeue()
        q.dequeue()
        q.dequeue()
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.dequeue()
        q.enqueue(sequenceNo())
        q.dequeue()
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
        q.dequeue()
        q.dequeue()
        q.enqueue(sequenceNo())
        q.enqueue(sequenceNo())
    }

}
```

QueueのMax sizeを変えて実験してみました。100万回のループ処理における速度結果を次に示します。
|Queue max|Queue.swift(seconds)|RingQueue.swift(seconds)|
|---------|-----------|---------------|
|10  |9.954|11.201|
|100 |12.377|10.863|
|1000|33.233|11.789|
|10000|232.331|10.712|

上記データをグラフにしてみました。縦軸はQueueのMax size、横軸は100万回処理にかかった秒数を表します。
image:/images/queue-test-graph.jpg

QueueのMax sizeが小さい場合は、どちらのアルゴリズムでも大した差はありません。しかし、Max sizeが大きくなるほど`Queue.swift`では顕著に速度が遅くなってしまいました。これは最初に説明した通り、C言語と同様にSwiftでもArrayをシフト処理をしているからだと思われます。
一方、`RingQueue.swift`の方は、Max sizeを変えても速度変化はみられませんでした。それもそのはず、Arrayそのものは増やしたり、減らしたりせず、参照するインデックスを足したり減らしたりしているだけなので、QueueのMax sizeには依存しないのです。

本プログラムはChiMAKiプロジェクトへ実装しましたので、ご参照ください。
https://github.com/araemon/chimaki/tree/master/Chimaki/Queue

<a target="_blank"  href="https://www.amazon.co.jp/gp/product/4797366249/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4797366249&linkCode=as2&tag=101010fun-22&linkId=3fdf21a47fcaea6368785832ba3bd506"><img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=4797366249&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL250_&tag=101010fun-22" ></a><img src="//ir-jp.amazon-adsystem.com/e/ir?t=101010fun-22&l=am2&o=9&a=4797366249" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><a target="_blank"  href="https://www.amazon.co.jp/gp/product/B00FR78X64/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=B00FR78X64&linkCode=as2&tag=101010fun-22&linkId=4d3bca9491477b3f1228dc3bf6f26d0b"><img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=B00FR78X64&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL250_&tag=101010fun-22" ></a><img src="//ir-jp.amazon-adsystem.com/e/ir?t=101010fun-22&l=am2&o=9&a=B00FR78X64" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />